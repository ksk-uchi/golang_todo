# レビュー

## 指摘事項

- [Q(Done)] `backend/services/todo.go` の `UpdateTodo` や `UpdateDoneStatus` で `txCtx := ent.NewContext(ctx, tx.Client())` としていますが、 `txCtx := ent.NewTxContext(ctx, tx)` のように実装しなかったのはどうしてでしょうか？
  - `Orders/00010_done_state/001.order.md` の対応を依頼したのですが、`git log` で確認すると、最後フロントエンドの対応の際に `NewTxContext` から `NewContext` の使用に変更した様子です。どうしてこのように変更したのでしょうか？
- [Done] `backend/services/todo.go` の `UpdateTodo` や `UpdateDoneStatus` で `txCtx := ent.NewContext(ctx, tx.Client())` としていますが、 `txCtx := ent.NewTxContext(ctx, tx)` のように実装し直してください。リポジトリ層は `getEntClient` を使って、トランザクション内のクライアントがあればそちらを採用し、なければクライアントを使用するように実装されています。
- [Done] `package utils` に、`ctx` から `ent.Client` を取得しトランザクションを作って `ent.NewTxContext(ctx, tx)` の結果のコンテキストを返却する関数を実装してください。そしてそれを `backend/services/todo.go` の各所で使うようにしてください。
- [Q(Done)] `backend/errors/errors.go` のパッケージが `apperrors` となっていますが `app_errors` のようにせず `apperrors` とするのは golang の流儀でしょうか？
  - 特に流儀とかでなければ `app_errors` のほうがわかりやすいのでそうしたいです。
- [Done] `backend/errors/errors.go` のパッケージが `apperrors` となっていますが `app_errors` に変更してください。呼び出し元のファイルも同様に変更してください。
- [Done] `backend/services/todo.go` の `UpdateTodo` ですが `title` `description` が両方 nil のときは `s.repo.GetTodoForUpdate(txCtx, id)` しなくていいので、トランザクションを作成する前に条件分岐してほしいです。
  - なんならバリデーションで実装できると素敵なのですが、そのように実装してもらえますか？
- [Done] `backend/services/todo.go` の `UpdateTodo` ですが、 `GetTodoForUpdate` ですでに更新対象のデータが取得できているため `backend/repositories/todo.go` の `UpdateTodo` メソッドは前半のユーザー取得と、指定の ID がユーザーに紐づくかの確認が不要です。更新する際に WHERE 句でユーザー ID を確認するのは最低限のチェックとして実装を残してほしいですが、前半部分の不要な箇所は削除してください。
- [Done] `backend/services/todo.go` の `UpdateDoneStatus` でリポジトリの `UpdateDoneStatus` だけを呼び出していますが、 `GetTodoForUpdate` を呼び出して行ロックしてから呼び出すようにしてください。またリポジトリの `UpdateDoneStatus` は行ロックを取るロジックが内部に含まれていますが、ToDo の完了状態 (done_at の有無) を更新することに専念してください。それ以外のことはサービスにまかせてください。
- [Done] `backend/repositories/todo.go` の `UpdateDoneStatus` で `executeUpdate` という関数を作っていますが、実装が愚直すぎる気がします。更新しないパターンで早期リターンするなど、読みやすい実装にリファクタリングしてください。
  - それにこのロジックもリポジトリではなくサービスに実装するのが順当だと思います。実装するために対象のレコード情報が必要ですが、一つ上のレビューによって `GetTodoForUpdate` を呼び出し、結果として更新対象レコードを取得出来るはずなのでサービス側でもこのロジックを実行できるはずです。
- [Q(Done)] `backend/repositories/todo.go` にいくつか `SQLite` のための迂回策が実装されています。テストで SQLite を使っているのでテストをパスするためにこのように実装したのだと思うのですが、プロダクトコードにテストのための実装を仕込むのは NG です。サービスのテストはリポジトリ層をモック化してテストするので問題ないのですが、一方でハンドラのテストは疑似リクエストを発生させるレベルのテストなので、モック化が難しく、そのためこのような実装がプロダクトコードに入り込んだのかなと推測します。Python の `unittest.mock` とかだとファイルパスの指定で、動的にインポートする前にモック化を予約できたりするのですが、 Go だと難しいのでしょうか？
  - どうしても難しいようであればローカルのテストはスキップして CI (Github Actions) で MySQL コンテナに対してテストが走るようにしてもいいかな？って考えているのですが、アイディアがほしいです。
- [Done] `backend/repositories/todo.go` にいくつか `SQLite` のための迂回策が実装されていますが、プロダクトコードにテストのための実装を仕込むのは辞めてください。後ほど別のタスクでローカルのテストはスキップして CI (Github Actions) で MySQL コンテナに対してテストが走るようにするので、ローカルではスキップできるようにしてください。

## 作業ガイドライン

作業に当たり下記のガイドラインを必ず遵守してください

- Implementation Plan, Task, Walkthrough は日本語で出力してください
- **指摘事項に対応する場合は1点につき1コミット作成すること**
- 指摘事項が `[Q]` から始まるものがあれば、**すべての対応を行う前に**質問に回答すること
  - 回答が得られた `[Q]` は `[Q(Done)]` に変更します
    - `[Q(Done)]` は質問したことをログとして残すために使用します
    - `[Q(Done)]` から始まる指示は無視してください
  - 回答に応じて `[Do]` または `[Q]` から始まる指示を追記します
- 対応方法が複数考えられるものがある場合は、すべての対応を行う前に対応方法を説明し、どの方法を選択するか確認すること
  - その説明に応じて `[Do]` または `[Q]` から始まる指示を追記します
- `[Q]` から始まる指摘事項や対応方法が不明確な指摘事項がなくなったら対応を開始すること
- 指摘事項が `[Do]` から始まる場合は、指示に従い対応すること
